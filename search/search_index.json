{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gruppe 1","text":"<p>Kasper Nielsen, Kristoffer Madsen &amp; Signe Wehlast</p>"},{"location":"#links","title":"Links","text":"<ul> <li>End to End testing</li> <li>Versionsstyring</li> <li>Statisk kode analyse</li> <li>Unitest</li> </ul>"},{"location":"e2etest/","title":"End to End testing","text":"<p>End-to-end testing anvendes til at tjekke et helt flow i ens applikation fra start til slut ud fra, hvordan brugeren kunne interagere p\u00e5 applikationen. Her testes om alt funktionalitet og navigationen p\u00e5 siden virker, som det skal.</p> <p>Til at teste flowet anvendes Cypress. Til at lave en end-to-end test skal der laves en mappe, som hedder 'e2e' hvor ens test-filer ligger (udover de mapper, som Cypres selv opretter). Inde i denne e2e-mappe oprettes filer, hvori koden der testet p\u00e5 laves.</p> <p>Til den ene udf\u00f8rte end-to-end test er flowet, at en bruger logger ind, laver et nyt skema og til sidst gemmer skemaet. Her er der oprettet filen createSkema.cy.js og her skrives koden til ens test.</p> <p>Det der st\u00e5r ved beforeEach er det, der k\u00f8rer inden hver test.</p> <p>Her kan den kode, der k\u00f8rer ses. Her kan det blandt andet ses, at den skal logge ind med brugernavn og email, og derefter g\u00e5 ind p\u00e5 skema siden og derefter oprette et skema med det mockdata, der st\u00e5r.</p> <p></p> <p>Her kan det ses, at testen k\u00f8rer, hvortil den til slut vil melde fejl, hvis der er fejl i ens flow, mens der vil komme flueben ud fra det hele, hvis flowet k\u00f8rer, som det skal.</p> <p></p> <p>I den anden test tester vi p\u00e5, at der kan oprettes en bruger.</p> <p>Her kan det ses, at den g\u00e5r ind p\u00e5 login siden, og derefter hen p\u00e5 opret bruger. Derefter opretter den en bruger med den mockdata, der er angivet. Derefter opretter den brugeren.</p> <p></p> <p>Derefter kan det ses, at den gennemf\u00f8rer flowet.</p> <p></p>"},{"location":"github/","title":"Versionsstyring","text":""},{"location":"github/#github-og-branching","title":"GitHub og branching","text":"<p>Til versionsstyring af dette projekt er GitHub anvendt.</p> <p>Platformen GitHub g\u00f8r det muligt at arbejde flere omkring et projekt. Der oprettes et repository, hvori koden deles ved brug af commits og push-requests. Dermed er der en versionsstyring, hvori der hele tiden kan g\u00e5s tilbage til tidligere versioner af koden.</p> <p>N\u00e5r der l\u00e6gges \u00e6ndringer op p\u00e5 GitHub, s\u00e5 skrives der ogs\u00e5 en beskrivelse af, hvad der \u00e6ndret. Et eksempel p\u00e5 dette:</p> <p></p> <p></p> <p>Der er gjort brug af branches, ved brug af strategien feature branching. Der er lavet features og sider i de forskellige branches, og n\u00e5r disse er f\u00e6rdige, l\u00e6gges de op p\u00e5 main-branch. </p> <p>Her er et eksempel p\u00e5 starten af vores branching, hvor der f\u00f8rst er oprettet et projekt og derefter er lavet features:</p> <p></p>"},{"location":"github/#github-actions","title":"GitHub actions","text":"<p>Der er brugt GitHub actions til automatisk at bygge og deploye denne MkDocs side til GitHub Pages. GitHub actions k\u00f8rer igennem en yaml-fil, som her er 'deploy-docs.yml'.</p> <p></p> <p>Det kan ses p\u00e5 linje 2-8, at dette workflow k\u00f8rer, n\u00e5r der enten pushes til main eller laves et pull request. Derudover fort\u00e6ller filen, at der ops\u00e6ttes og installeres python.</p> <p>P\u00e5 linje 27-31 er der, hvor den deployer \u00e6ndringerne til GitHub Pages, hvor den s\u00e5 finder det brugernavn og e-mail p\u00e5 den, der startede workflowet. Derefter pushes det til branchen gh-pages, som er den branch, der h\u00f8rer sammen med GitHub Page-siden.</p> <p>Det kan ses her, at \u00e6ndringerne l\u00e6gges op p\u00e5 main, mens det ogs\u00e5 bliver builded og deployet til branchen, gh-pages:</p> <p></p> <p>Dermed k\u00f8rer denne GitHub action, n\u00e5r der pushes \u00e6ndringer, hvortil det buildes og deployes op til GitHub Pages siden.</p>"},{"location":"staticcodeanalysis/","title":"Statisk kode analyse","text":""},{"location":"staticcodeanalysis/#eslint-og-refaktorering","title":"ESLint og refaktorering","text":"<p>Til at lave statisk kode analyse er der anvendt ESLint og linting regler.</p> <p></p> <p>Der er lavet reglerne:</p> <ul> <li> <p>Den f\u00f8rste curly-bracket skal st\u00e5 p\u00e5 samme linje for koden, mens den sidste skal st\u00e5 p\u00e5 egen linje.</p> </li> <li> <p>Ingen comma-dangle (ingen komma uden efterf\u00f8lgende punkter).</p> </li> <li> <p>Der skal bruges 2 mellemrum til indrykning.</p> </li> <li> <p>Ingen brug af eval.</p> </li> <li> <p>Der m\u00e5 maks v\u00e6re to tomme linjer efter hinanden og ingen tomme linjer i slutningen af en fil.</p> </li> <li> <p>Ingen mellemrum efter semikolon.</p> </li> <li> <p>Ingen ubrugte variabler.</p> </li> <li> <p>Ingen brug af variabeltypen 'var'.</p> </li> <li> <p>Brug altid const, hvis variablen ikke \u00e6ndrer sig.</p> </li> <li> <p>Altid bruge singlequotes.</p> </li> <li> <p>Altid bruge semikolon.</p> </li> </ul> <p>Linting regler er lavet for at holde en ensartet kodestruktur, og dermed hj\u00e6lpe teamet med at holde den kodestandard, som er aftalt i teamet. Dermed kan man ved brug af ESLint finde de uoverenstemmerlser, der er med de regler, som er opsat og dermed udbedre dem. Derfor kan der inden, der laves et commit til GitHub k\u00f8res en ESLint, s\u00e5 det kode, der l\u00e6gges op altid f\u00f8lger kodestandarden.</p>"},{"location":"staticcodeanalysis/#eksempel-pa-eslint-fejl-som-efterflgende-er-blevet-refaktoreret","title":"Eksempel p\u00e5 ESLint fejl, som efterf\u00f8lgende er blevet refaktoreret:","text":""},{"location":"unitest/","title":"Unitest","text":"<p>Ved brug af unit testing testes individuelle komponenter for sig selv. Her testet kun en funktion, hvortil det ses, om den g\u00f8r, som den skal.</p> <p>Til at lave unit tests laves der en fil til at teste i, som kaldes filnavnet.test.js. I disse filer bruges describe, som bruges til at l\u00e6gge relaterede test sammen. Herinde i bruges it, som indeholder hver test for sig.</p> <p>Derudover er der beforeEach, som er en funktion, der k\u00f8rer inden hver test, som er i describe-blokken.</p> <p>Der er lavet fem unit test, hvor de f\u00f8rste to er p\u00e5 DBI projektet, mens de sidste tre er p\u00e5 en lommeregner.</p> <p>I den f\u00f8rste og anden test bliver der testet p\u00e5, om den filtrerer korrekt p\u00e5 statussen.</p> <p></p> <p>Her er der filen ScheduleStore.spec.js, som er test filen til ScheduleStore. I beforeEach fort\u00e6lles, at der skal bruges state-manageren pinia til hver test.</p> <p>I den f\u00f8rste test tjekkes der for, at der kun returneres de skemaer, som har statussen 'overskredet'. Dette testes med mockdata. </p> <p>I test to testet det, at der skal returneres en tom liste, hvis der ikke er nogen overskredne overskredne skemaer.</p> <p>Begge disse test er passed, kan der ses her:</p> <p></p> <p>I test tre, fire og frem testet der p\u00e5 en lommeregner:</p> <p></p> <p>Her testes det om lommeregneren kan plus, minus og gange.</p>"}]}